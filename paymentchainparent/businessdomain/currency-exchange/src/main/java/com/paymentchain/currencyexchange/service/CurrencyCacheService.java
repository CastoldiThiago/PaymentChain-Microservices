package com.paymentchain.currencyexchange.service;

import com.paymentchain.currencyexchange.dtos.ExchangeRateApiResponse;
import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.cache.CacheManager;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.math.BigDecimal;

@Service
@Slf4j
public class CurrencyCacheService {

    private final RestTemplate restTemplate = new RestTemplate();

    @Value("${external.api.exchange-rate.url}")
    private String baseUrl;

    @Value("${external.api.exchange-rate.key}")
    private String apiKey;

    @Autowired
    private CacheManager cacheManager;

    /**
     * Public cacheable method. Key is generated by the global KeyGenerator bean to avoid null/invalid keys.
     */
    @Cacheable(value = "exchangeRates", keyGenerator = "keyGenerator", condition = "#from != null and #to != null", unless = "#result == null")
    @CircuitBreaker(name = "externalApi", fallbackMethod = "fallbackRate")
    public BigDecimal getExchangeRateCached(String from, String to) {
        log.info("[CurrencyCacheService] getExchangeRateCached called with from='{}', to='{}'", from, to);
        String fromUpper = from.toUpperCase();
        String toUpper = to.toUpperCase();
        log.info("âš¡ Fetching exchange rate from external API: {} -> {}", fromUpper, toUpper);
        if (fromUpper.equals(toUpper)) return BigDecimal.ONE;

        String url = String.format("%s/%s/pair/%s/%s", baseUrl, apiKey, fromUpper, toUpper);
        try {
            ExchangeRateApiResponse response = restTemplate.getForObject(url, ExchangeRateApiResponse.class);
            if (response != null && "success".equalsIgnoreCase(response.getResult()) && response.getConversionRate() != null) {
                BigDecimal rate = response.getConversionRate();
                // Manual cache write as a safeguard (ensures Redis SET occurs even if proxy not active)
                try {
                    String key = fromUpper + "_" + toUpper;
                    if (cacheManager != null) {
                        log.info("[CurrencyCacheService] Manually putting rate into cache exchangeRates:{} -> {}", key, rate);
                        if (cacheManager.getCache("exchangeRates") != null) {
                            cacheManager.getCache("exchangeRates").put(key, rate);
                        } else {
                            log.warn("[CurrencyCacheService] cache 'exchangeRates' not found in CacheManager");
                        }
                    }
                } catch (Exception inner) {
                    log.warn("[CurrencyCacheService] Failed manual cache put: {}", inner.getMessage());
                }

                return rate;
            } else {
                log.error("Unexpected response from exchange API: {}", response);
                throw new RuntimeException("Error obtaining exchange rate");
            }
        } catch (Exception e) {
            log.error("Failed calling ExchangeRate API: {}", e.getMessage(), e);
            throw e;
        }
    }

    // --- FALLBACK METHOD ---
    public BigDecimal fallbackRate(String from, String to, Throwable t) {
        log.warn("ðŸ›¡ï¸ Activating fallback for: {} -> {}. Cause: {}", from, to, t == null ? "-" : t.getMessage());

        if (from == null || to == null) return BigDecimal.ONE;
        if ("USD".equalsIgnoreCase(from) && "ARS".equalsIgnoreCase(to)) return new BigDecimal("1400");
        if ("EUR".equalsIgnoreCase(from) && "ARS".equalsIgnoreCase(to)) return new BigDecimal("1500");

        return BigDecimal.ONE;
    }
}
